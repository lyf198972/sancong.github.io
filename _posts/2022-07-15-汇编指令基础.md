---
layout: post
title: 汇编指令基础
---

简要介绍汇编指令的基本使用方法

## 数据传送指令 -- mov
**格式:** mov 目标, 源  
**例如**  
+ mov 寄存器, 数据
  `如：mov ax, 8`
+ mov 寄存器, 寄存器
  `如：mov ax, bx`
+ mov 寄存器, 内存单元
  `如: mov ax, [0]<br/>[...]表示一个内存单元，[0], 0表示内存单元的偏移地址，数据段地址从ds寄存器中获取。`
+ mov 内存单元，寄存器
  `如: mov [0], ax`
+ mov 段寄存器，寄存器
  `如: mov ds,ax`
+ mov 寄存器, 段寄存器

**注意**  
1) MOV指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）和IP；段寄存器之间不能直接传送。MOV IP，2000 H ；这是错误的  
2) CS和IP不能作为目的操作数。MOV CS，AX ；这是错误的  
3) MOV指令中立即数不能作目标操作数。MOV 2000H，[SI] ；这是错误的  

**备注**
<font color="#dd0000">为什么x86cpu不支持将数据直接送入段寄存器的操作？？？</font>  
<font color="#006600">解答: </font>这属于x86的硬件涉及问题

----------
## 位测试指令 -- bt、btc、btr、bts
**功能说明**
```
BT(Bit　Test): 位测试　
BTS(Bit　Test　and　Set): 位测试并置位　
BTR(Bit　Test　and　Reset): 位测试并复位　
BTC(Bit　Test　and　Complement): 位测试并取反

它们的执行影响CF标志位
```
**举例说明**
```
; bt把10000001b的第七位1复制到CF
  mov dx, 10000001b
  bt dx, 7

; bts在执行bt命令的同时，把操作数指定的位置为1
  mov dx, 10000001b
  bts dx, 6

; btr在执行bt命令的同时，把操作数指定的位置位0
  mov dx, 10000001b
  btr dx, 7

; btc在执行bt命令的同时，把草所指定的位取反
  mov dx, 10000001b
  btc dx, 0
```

-------
## 异或指令 -- xor
**指令格式:** xor dst, src  
**功能描述:** 两个操作数的每一对对应位都应用如下操作原则：如果两个位的值相同（同为 0 或同为 1），则结果位等于 0；否则结果位等于 

-------
## 伪指令
### segment和ends
segment和ends是一对成对使用的伪指令，功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。一个段必须有一个名称来标识。  
**使用格式如下：**  
```
段名 segment
  :
段名 ends

如:
codesg segment
  :
codesg ends
```

### end
**作用一：**  
end表示一个汇编程序的结束标记，编译器在编译汇编的过程中，如果碰到了伪指令end,就结束对伪指令的编译。  
**注意:** 不要和ends搞混了，是不一样的。

**作用二：**  
通知编译器程序的入口在什么地方。  
在单任务系统中，可执行文件中的程序执行过程如下:  
1) 由其他的程序(debug、cmd或其他程序)将可执行文件中的程序加载如内存。  
2) 设置CS:IP指向的第一条执行的指令(即程序的入口), 从而使程序得以运行。  
3) 程序运行结束后，返回到加载者。  
  
使如何设置cpu的CS:IP指向程序的第一条指令呢？  
这是由可执行文件中的描述信息指明的。  
可执行文件由描述信息和程序组成，程序来自源程序中的汇编指令和定义的数据；描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。  
使用伪指令end描述了程序的结束和程序的入口。在编译和连接后，由end start指明了程序入口为标号start处，被转换为一个入口地址，存储在可执行文件的描述信息中。
**例如,程序的框架可以这么写：**
```
assume cs:code
code segment
  :
  数据
  :
start:
  :
  代码
  :
code ends
end start
```

### assume
这条伪指令的含义是"假设"。它假设某一个段寄存器和程序中的某一用segment...ends定义的段相关联。通过assume说明这种关联。
**使用格式如下：**  
```
assume 段寄存器:段名称

如: assume cs:codesg
```

## 标号
在汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如"codesg"。一个标号指代了一个地址。  
如：codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

--------
## 目标地址传送指令 -- lea
lea，官方解释Load Effective Address，即装入有效地址的意思。  
**常见用法如下:**  
1. lea eax，[addr]  
就是将表达式addr的值放入eax寄存器，示例如下：  
lea eax,[401000h]; 将值401000h写入eax寄存器中。  
lea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的。  lea的[]中可以做算数运算，这比mov的功能强大，可以减少汇编指令，提高效率。  
2. lea eax，dword ptr [ebx]  ;将ebx的值赋值给eax  
3. lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax。  

------
## 中段指令 -- int
[int 21h 功能描述](https://blog.csdn.net/mid_Faker/article/details/112271486)

------
## 数据定义
**DB:**  定义的变量为字节型 Define Byte  
**DW:**  定义的变量为字类型（双字节）Define Word  
**DD:**  定义的变量为双字型（4字节）Define Double Word  
**DQ:**  定义的变量为4字型（8字节）Define Quadra Word  
**DT:**  定义的变量为10字节型 Define Ten Byte  

-----