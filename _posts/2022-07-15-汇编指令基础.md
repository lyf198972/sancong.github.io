---
layout: post
title: 汇编指令基础
---

# 汇编种类 -- Inter&ATT
[Intel语法和AT&T语法的基本区别](https://zhuanlan.zhihu.com/p/412862518)  
[AT&T汇编语法](https://kdocs.cn/l/ctG1o8BTTdSV)  
[关于nasm：什么是汇编语言中的global _start？](https://www.codenong.com/17898989/)  

-----------

## 数据传送指令 -- mov
**格式:** mov 目标, 源  
**例如**  
+ mov 寄存器, 数据
  `如：mov ax, 8`
+ mov 寄存器, 寄存器
  `如：mov ax, bx`
+ mov 寄存器, 内存单元
  `如: mov ax, [0]<br/>[...]表示一个内存单元，[0], 0表示内存单元的偏移地址，数据段地址从ds寄存器中获取。`
+ mov 内存单元，寄存器
  `如: mov [0], ax`
+ mov 段寄存器，寄存器
  `如: mov ds,ax`
+ mov 寄存器, 段寄存器

**注意**  
1) MOV指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）和IP；段寄存器之间不能直接传送。MOV IP，2000 H ；这是错误的  
2) CS和IP不能作为目的操作数。MOV CS，AX ；这是错误的  
3) MOV指令中立即数不能作目标操作数。MOV 2000H，[SI] ；这是错误的  

**备注**
<font color="#dd0000">为什么x86cpu不支持将数据直接送入段寄存器的操作？？？</font>  
<font color="#006600">解答: </font>这属于x86的硬件涉及问题

----------
## 位测试指令 -- bt、btc、btr、bts
**功能说明**
```
BT(Bit　Test): 位测试　
BTS(Bit　Test　and　Set): 位测试并置位　
BTR(Bit　Test　and　Reset): 位测试并复位　
BTC(Bit　Test　and　Complement): 位测试并取反

它们的执行影响CF标志位
```
**举例说明**
```
; bt把10000001b的第七位1复制到CF
  mov dx, 10000001b
  bt dx, 7

; bts在执行bt命令的同时，把操作数指定的位置为1
  mov dx, 10000001b
  bts dx, 6

; btr在执行bt命令的同时，把操作数指定的位置位0
  mov dx, 10000001b
  btr dx, 7

; btc在执行bt命令的同时，把草所指定的位取反
  mov dx, 10000001b
  btc dx, 0
```

-------
## 异或指令 -- xor
**指令格式:** xor dst, src  
**功能描述:** 两个操作数的每一对对应位都应用如下操作原则：如果两个位的值相同（同为 0 或同为 1），则结果位等于 0；否则结果位等于1

-------
## 伪指令
### segment和ends
segment和ends是一对成对使用的伪指令，功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。一个段必须有一个名称来标识。  
**使用格式如下：**  
```
段名 segment
  :
段名 ends

如:
codesg segment
  :
codesg ends
```

### end
**作用一：**  
end表示一个汇编程序的结束标记，编译器在编译汇编的过程中，如果碰到了伪指令end,就结束对伪指令的编译。  
**注意:** 不要和ends搞混了，是不一样的。

**作用二：**  
通知编译器程序的入口在什么地方。  
在单任务系统中，可执行文件中的程序执行过程如下:  
1) 由其他的程序(debug、cmd或其他程序)将可执行文件中的程序加载如内存。  
2) 设置CS:IP指向的第一条执行的指令(即程序的入口), 从而使程序得以运行。  
3) 程序运行结束后，返回到加载者。  
  
使如何设置cpu的CS:IP指向程序的第一条指令呢？  
这是由可执行文件中的描述信息指明的。  
可执行文件由描述信息和程序组成，程序来自源程序中的汇编指令和定义的数据；描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。  
使用伪指令end描述了程序的结束和程序的入口。在编译和连接后，由end start指明了程序入口为标号start处，被转换为一个入口地址，存储在可执行文件的描述信息中。
**例如,程序的框架可以这么写：**
```
assume cs:code
code segment
  :
  数据
  :
start:
  :
  代码
  :
code ends
end start
```

### assume
这条伪指令的含义是"假设"。它假设某一个段寄存器和程序中的某一用segment...ends定义的段相关联。通过assume说明这种关联。
**使用格式如下：**  
```
assume 段寄存器:段名称

如: assume cs:codesg
```

## 标号
在汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如"codesg"。一个标号指代了一个地址。  
如：codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

--------
## 目标地址传送指令 -- lea
lea，官方解释Load Effective Address，即装入有效地址的意思。  
**常见用法如下:**  
1. lea eax，[addr]  
就是将表达式addr的值放入eax寄存器，示例如下：  
lea eax,[401000h]; 将值401000h写入eax寄存器中。  
lea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的。  lea的[]中可以做算数运算，这比mov的功能强大，可以减少汇编指令，提高效率。  
2. lea eax，dword ptr [ebx]  ;将ebx的值赋值给eax  
3. lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax。  

------
## 中段指令 -- int
[int 21h 功能描述](https://blog.csdn.net/mid_Faker/article/details/112271486)  
[int 15h 功能描述](https://blog.csdn.net/Yes_life/article/details/6839453)  

------
## 数据定义
**DB:**  定义的变量为字节型 Define Byte  
**DW:**  定义的变量为字类型（双字节）Define Word  
**DD:**  定义的变量为双字型（4字节）Define Double Word  
**DQ:**  定义的变量为4字型（8字节）Define Quadra Word  
**DT:**  定义的变量为10字节型 Define Ten Byte  

-----

## 等值命令 -- EQU
1、用符号名代表字符串 。用一个具有一定含义的符号名定义某一个较长的字符串，在随后的程序中就用该符号名。例如:  
GREETING EQU "How are you!"  
在该定义之后，就可使用符号名GREETING来代表字符串"How are you!"。  
2、用符号名关键字或指令助忆符 。用一个(组)程序员自己习惯的符号名来代替汇编语言中的关键字或指令助忆符。但在此建议不要这样做，因为程序的编写者习惯，程序的其他阅读者可能会觉得很别扭。 例如:  
  MOVE EQU MOV ;给指令MOV取另一个符号名MOVE  
  COUNTER EQU CX ;给寄存器CX取一个叫“计数器”的符号名  
上面的定义只是给原来的助忆符MOV和CX起了另一个别名，而原来助忆符MOV和CX仍然可以使用，所以，可编写如下语句：  
  MOVE AX, CX ;相当于指令：MOV AX, CX  
  MOV COUNTER, BX ;相当于指令：MOV CX, BX  

-----

## 无条件转移指令 -- JMP
jmp为无条件转移指令，可以值修改IP，也可以同时修改CS和IP。
jmp指令要给出俩种信息：
1. 转移的目的地址  
1. 转移的距离(段间转移、段内短转移、段内近转移)  
不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。  

### 段内短转移
jmp short 标号  
这只在段内转移，即只修改IP。(IP) = (IP) + 8位位移  
8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址。  
8位位移的范围为 -128~127，用补码表示。8位位移由编译程序在编译时计算。  

### 段内近转移
jmp near ptr 标号
这也是在段内转移，即只修改IP。(IP) = (IP) + 16位位移  
16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址。 
16位位移的范围为 -32768~32767，用补码表示。16位位移由编译程序在编译时计算。  

### 段间转移，又称远转移
jmp far ptr 标号
(CS) = 标号所在的段的段地址；(IP) = 标号在段中的偏移地址。  
far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。  

### 转移地址在寄存器中
jmp 16寄存器
段内转移, 只修改IP， (IP) = (16位寄存器)  
如：jmp ax  
执行前: ax=1000H, CS=2000H, IP=0003H  
执行后: ax=1000H, CS-2000H, IP=1000H  

### 转移地址在内存中
#### 段内转移
jmp word ptr 内存地址单元(段内转移)  
从内存单元地址处存放这一个字，是转移的目的偏移量。  
内存单元地址可用寻找方式的任一格式给出。  

#### 段间转移
jmp dword ptr 内存单元地址(段间转移)  
从内存单元地址处开始存放着俩个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。  
(CS) = (内存单元地址+2)  (IP) = (内存单元地址)  
内存单元地址可用寻找方式的任一格式给出。  
